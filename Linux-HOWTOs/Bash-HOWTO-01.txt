============
Bash HOWTO 1 (c) Nicolas Kovacs <info@microlinux.fr>
============

Dernière révision : 11 octobre 2015


  * Définition du shell
  * Commandes externes et internes
  * Affichage à l'écran
  * La commande interne 'cd'
  * Substitution de noms de fichiers
  * Expressions complexes


Définition du shell
-------------------

Le shell est un programme ayant pour fonction d'assurer l'interface entre
l'utilisateur et le système Linux. C'est un interpréteur de commandes.

Plusieurs shells sont disponibles sur les plates-formes Linux.


Commandes externes et internes
------------------------------

Une commande Linux appartient à l'une des deux catégories suivantes :

  * commandes externes
  * commandes internes

Une commande externe est un fichier localisé dans l'arborescence. Par exemple,
lorsqu'un utilisateur lance la commande 'ls', le shell demande au noyau Linux
de charger en mémoire le fichier '/bin/ls'. 

Sont considérées comme commandes externes les fichiers possédant l'un des
formats suivants :

  * fichiers au format binaire exécutable
  * fichiers au format texte représentant un script de commandes

La commande 'file' donne une indication sur le type de données contenues dans
un fichier. L'argument de la commande 'file' est un nom de fichier exprimé en
relatif ou en absolu. Voici deux exemples.

La commande 'ls' est un fichier au format binaire exécutable :

  $ file /bin/ls
  /bin/ls: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically
  linked (uses shared libs), stripped

La commande 'gettext.sh' est un script shell :

  $ file /usr/bin/gettext.sh
  /usr/bin/gettext.sh: POSIX shell script, ASCII text executable

Une commande interne est intégrée au processus shell. Elle ne correspond donc
en aucun cas à un fichier sur le disque. 

La commande 'type' indique si une commande possède une implémentation interne.
Elle prend en argument le nom d'une commande. Si cette dernière n'est pas
interne, elle est recherchée dans les répertoires cités dans PATH. Voici deux
exemples.

La commande 'cd' est une commande interne :

  $ type cd
  cd est une primitive du shell

La commande 'ls' est une commande externe :

  $ type -a ls
  ls est un alias vers « ls --color=auto »
  ls est /usr/bin/ls
  ls est /bin/ls

  /!\ Ici on invoque l'option '-a' pour afficher les infos sur l'ensemble des
  exécutables nommés 'ls'. Pour plus d'infos, voir 'man bash'.

Certaines commandes ont une implémentation interne et une implémentation
externe. Dans ce cas, la commande interne est lancée en priorité. L'exécution
d'une commande interne est plus rapide que l'exécution d'une commande externe.

La commande 'pwd' est une commande interne au shell :

  $ type pwd
  pwd est une primitive du shell

Elle possède également une implémentation externe :

  $ type -a pwd
  pwd est une primitive du shell
  pwd est /usr/bin/pwd
  pwd est /bin/pwd
  $ ls -l /usr/bin/pwd
  lrwxrwxrwx 1 root root 13 avril 26 08:07 /usr/bin/pwd -> ../../bin/pwd

C'est la commande interne qui est exécutée en priorité :

  $ pwd
  /home/kikinovak

Pour forcer l'exécution de la commande externe, il faut indiquer explicitement
l'emplacement de la commande, en absolu ou en relatif :

  $ /usr/bin/pwd 
  /home/kikinovak
  $ cd /usr/bin/
  $ ./pwd 
  /usr/bin


Affichage à l'écran
-------------------

La commande interne 'echo' permet de réaliser des affichages à l'écran.

  $ echo Yatahongaga !
  Yatahongaga !

Certains caractères ont une signification spéciale lorsqu'ils sont placés
entre simples ou doubles quotes (apostrophes ou guillemets). Ce sont des
caractères d'échappement. 

  /!\ La commande 'echo' du shell Bash doit être utilisée avec l'option '-e'
  pour que l'interprétation des caractères d'échappement ait lieu. Pour plus
  de détails, voir 'man echo'.

Le caractère "\n" sert à provoquer un saut de ligne :

  $ echo -e "Première ligne\nDeuxième ligne\nTroisième ligne"
  Première ligne
  Deuxième ligne
  Troisième ligne

On peut également utiliser des apostrophes au lieu des guillemets :

  $ echo -e 'Première ligne\nDeuxième ligne\nTroisième ligne'
  Première ligne
  Deuxième ligne
  Troisième ligne

Le caractère "\c" sert à éliminer le saut de ligne naturel de la commande
'echo'. Il doit se situer impérativement en dernière position de l'argument de
'echo', juste avant le guillemet fermant. L'option '-e' est indispensable pour
l'interprétation du caractère d'échappement "\c".

  $ echo "Première ligne" ; echo "Deuxième ligne"
  Première ligne
  Deuxième ligne
  $ echo -e "Première ligne\c" ; echo -e "Deuxième ligne\c"
  Première ligneDeuxième ligne $ 

Alternativement, l'option '-n' peut remplacer le caractère "\c" :

  $ echo -n "Première ligne" ; echo -n "Deuxième ligne"
  Première ligneDeuxième ligne $ 

Le caractère "\t" permet d'afficher une tabulation :

  $ echo -e "|\tTab 1\tTab 2\tTab 3\tTab 4\t|"
  | Tab 1 Tab 2 Tab 3 Tab 4 |


La commande interne 'cd'
------------------------

La commande 'cd' sans argument permet à l'utilisateur de revenir dans son
répertoire d'accueil :

  $ cd 
  $ pwd
  /home/kikinovak

Même chose en utilisant le caractère '~', qui représente le répertoire
d'accueil de l'utilisateur courant :

  $ cd ~
  $ pwd
  /home/kikinovak

Se déplacer dans le répertoire d'accueil de l'utilisateur 'ftp' :

  $ cd ~ftp
  $ pwd
  /home/ftp

Revenir dans le répertoire précédent :

  $ cd -


Substitution de noms de fichiers
--------------------------------

De nombreuses commandes prennent des noms de fichiers en argument. Ces
derniers peuvent être cités littéralement ou être spécifiés de manière plus
générique. 

Le caractère "*" représente une suite de caractères quelconques. Voici
quelques exemples.

  $ ls
  f12  f1.i  FICa  fic.c  fic.s  monscript.pl  MONSCRIPT.pl  ours.c

  /!\ Pour créer tous ces fichiers, on pourra utiliser la commande 'touch'.

Afficher tous les noms de fichier se terminant par ".c" :

  $ ls *.c
  fic.c  ours.c

Afficher tous les noms de fichier commençant par la lettre "f" :

  $ ls f*
  f12  f1.i  fic.c  fic.s

Le caractère "?" représente un caractère quelconque. Voici quelques exemples.

Afficher tous les noms de fichier ayant une extension composée d'un seul
caractère :

  $ ls *.?
  f1.i  fic.c  fic.s  ours.c

Afficher tous les noms de fichier composés de quatre caractères :

  $ ls ????
  f1.i  FICa

Les crochets "[ ]" permettent de spécifier la liste des caractères que l'on
attend à une position bien précise dans le nom du fichier. Il est également
possible d'utiliser les notions d'intervalle et de négation. 

  /!\ Les exemples cités ci-dessous peuvent produire des résultats surprenants
  en fonction de certaines variables d'environnement. Dans le doute, on fera
  ceci :
    
    $ LANG=C
    $ LC_COLLATE=C

  Pour chacun des exemples, une alternative est donnée qui fonctionne
  parfaitement pour des variables d'environnement LANG et LC_COLLATE
  différentes, par exemple 'fr_FR.utf8'.

Fichiers dont le nom commence par "f" ou "o" et se termine par le caractère
"." suivi d'une minuscule :

  $ ls [fo]*.[a-z]
  f1.i  fic.c  fic.s  ours.c

Alternativement :

  $ ls [fo]*.[[:lower:]]
  f1.i  fic.c  fic.s  ours.c

Fichiers dont le nom comporte en deuxième caractère une majuscule ou un
chiffre ou la lettre "i". Les deux premiers caractères seront suivis d'une
chaîne quelconque :

  $ ls ?[A-Z0-9i]*
  FICa  MONSCRIPT.pl  f1.i  f12  fic.c  fic.s

Alternativement :

  $ ls ?[[:upper:]0-9i]*
  f12  f1.i  FICa  fic.c  fic.s  MONSCRIPT.pl

Il est également possible d'exprimer la négation de tous les caractères
spécifiés à l'intérieur d'une paire de crochets. Ceci se fait en plaçant un
"!" en première position à l'intérieur de celle-ci.

Noms de fichier ne commençant pas par une minuscule :

  $ ls [!a-z]*
  FICa  MONSCRIPT.pl

Alternativement :

  $ ls [![:lower:]]*
  FICa  MONSCRIPT.pl

Noms de fichier ne commençant pas par une majuscule :

  $ ls [!A-Z]*
  f1.i  f12  fic.c  fic.s  monscript.pl  ours.c

Alternativement :

  $ ls [![:upper:]]*
  f12  f1.i  fic.c  fic.s  monscript.pl  ours.c

Supprimer tous les fichiers dont le nom se termine par ".c" ou par ".s" :

  $ rm -i *.c *.s
  rm : supprimer fichier « fic.c » ? o
  rm : supprimer fichier « ours.c » ? o
  rm : supprimer fichier « fic.s » ? o


Expressions complexes
---------------------

Pour utiliser les expressions complexes en Bash, il faut préalablement activer
l'option 'extglob' avec la commande suivante :

  $ shopt -s extglob

Voici le contenu du répertoire qui sera utilisé dans les exemples suivants :

  $ ls
  fic               fic866866.log  fic866.log  fic868.log  readme.txt
  fic866866866.log  fic866868.log  fic867.log  fic.log     typescript

L'expression "?(expression)" sera présente 0 ou 1 fois.

Fichiers dont le nom commence par "fic" suivi de 0 ou 1 occurrence de "866",
suivi de ".log" :

  $ ls fic?(866).log
  fic866.log  fic.log

L'expression "*(expression)" sera présente entre 0 et n fois. 

Fichiers dont le nom commence par "fic", suivi de 0 à n occurrence(s) de
"866", suivi de ".log" :

  $ ls fic*(866).log
  fic866866866.log  fic866866.log  fic866.log  fic.log

L'expression "+(expression)" sera présente entre 1 et n fois.

Fichiers dont le nom commence par "fic", suivi d'au moins une occurrence de
"866", suivi de ".log" :

  $ ls fic+(866).log
  fic866866866.log  fic866866.log  fic866.log

L'expression "@(expression)" sera présente exactement 1 fois.

Fichiers dont le nom commence par "fic", suivi exactement d'une occurrence de
"866", suivi de ".log" :

  $ ls fic@(866).log
  fic866.log

L'expression "!(expression)" ne sera pas présente.

Fichiers dont le nom commence par "fic", suivi d'une expression qui n'est pas
la chaîne "866", suivi de ".log" :

  $ ls fic!(866).log
  fic866866866.log  fic866866.log  fic866868.log  fic867.log  fic868.log
  fic.log

Fichiers dont le nom ne commence pas par "fic" :

  $ ls !(fic*)
  readme.txt  typescript

Une barre verticale "|" à l'intérieur d'une expression complexe prend le sens
de "ou bien". 

Fichiers dont le nom commence par "fic", suivi de "866" ou "867", suivi de
".log" :

  $ ls fic@(866|867).log
  fic866.log  fic867.log

Fichiers dont le nom commence par "fic", suivi de 1 à n occurrence(s) de "866"
ou "868", suivi de ".log" :

  $ ls fic+(866|868).log
  fic866866866.log  fic866866.log  fic866868.log  fic866.log  fic868.log


------------------------------------------------------------------------------
# vim: syntax=txt
