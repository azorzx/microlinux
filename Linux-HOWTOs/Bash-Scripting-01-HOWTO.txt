=======================
Bash Scripting 01 HOWTO (c) Nicolas Kovacs <info@microlinux.fr>
=======================

Dernière révision : 20 octobre 2015

Ce HOWTO présente les fonctionnalités qui composent les bases de la
programmation shell.


  * Les variables utilisateur
  * La substitution de variables
  * La substitution de commandes
  * Les caractères de protection


Les variables utilisateur
-------------------------

Le shell permet de définir ou redéfinir des variables qui conditionnent
l'environnement de travail de l'utilisateur. Il est également possible de
définir d'autres variables, dites variables utilisateur, qui vont permettre de
stocker des informations qui seront nécessaires à l'exécution d'un script.

Voici les règles à utiliser pour attribuer un nom à une variable :

  * le premier caractère fait partie de l'ensemble [a-zA-Z_] ;

  * les caractères suivants sont pris dans l'ensemble [a-zA-Z0-9_].

Une variable est définie dès qu'elle est initialisée. Le contenu d'une
variable est considéré par le shell comme une suite de caractères. 

  $ var1=mot1
  $ echo $var1
  mot1

  /!\ Il ne faut pas mettre d'espace autour du symbole d'affectation "=".

Si l'on affecte une valeur contenant au moins un espace, il faut protéger ce
dernier, étant donné que c'est un caractère spécial du shell (séparateur de
mots sur la ligne de commande) :

  $ var2='mot1 mot2 mot3'
  $ echo $var2
  mot1 mot2 mot3

Une variable qui n'a jamais été initialisée est vide.

  $ echo $var3

La commande interne 'unset' permet de retirer la définition d'une variable.

  $ var=12
  $ echo $var
  12
  $ set | grep var
  var=12
  $ unset var
  $ echo $var

  $ set | grep var

Il faut faire attention en concaténant le contenu d'une variable et d'une
chaîne de caractères à ce que le shell interprète correctement le nom de la
variable. Dans l'exemple ci-dessous, le caractère souligné "_" fait partie du
nom de la première variable :

  $ fic=resu
  $ datejour=20151020
  $ newfic=$fic_$datejour
  $ echo $newfic
  20151020

Pour le shell, la première variable se nomme "fic_", puisque le caractère
souligné "_" est autorisé à l'intérieur du nom d'une variable. Celle-ci est
donc substituée par sa valeur (donc vide), puis concaténée avec le contenu de
la variable "datejour". 

Pour faire comprendre au shell quels sont les caractères qui font partie du
nom de la variable, il faut entourer le nom de cette dernière avec des
accolades { } :

  $ fic=resu
  $ datejour=20151020
  $ newfic=${fic}_$datejour
  $ echo $newfic
  resu_20151020

La commande interne 'typeset' permet de déclarer explicitement une variable
comme étant un nombre entier. Cette déclaration est facultative, mais elle
permet d'avoir un contrôle sur la valeur stockée et rend les calculs plus
rapides. 

  $ typeset -i nb=1
  $ echo $nb
  1


La substitution de variables
----------------------------

Le shell offre la possibilité d'attribuer une valeur par défaut aux variables
non initialisées ou, au contraire, initialisées.

Expression ${variable:-valeur} :

  - Si la variable n'est pas vide, l'expression est substituée par
    "$variable".
  
  - Si la variable est vide, l'expression est substituée par "valeur".

  $ fic=/tmp/kikinovak.log
  $ echo "Le fichier traité sera : ${fic:-/tmp/default.log}."
  Le fichier traité sera : /tmp/kikinovak.log.
  $ unset fic
  $ echo "Le fichier traité sera : ${fic:-/tmp/default.log}."
  Le fichier traité sera : /tmp/default.log.
  $ echo $fic

Expression ${variable:=valeur} :

  - Si la variable n'est pas vide, l'expression est substituée par
    "$variable".
  
  - Si la variable est vide, "variable" est affectée avec "valeur", et
    l'expression est substituée par "valeur".

  $ fic=/tmp/kikinovak.log
  $ echo "Le fichier traité sera : ${fic:=/tmp/default.log}."
  Le fichier traité sera : /tmp/kikinovak.log.
  $ unset fic
  $ echo "Le fichier traité sera : ${fic:=/tmp/default.log}."
  Le fichier traité sera : /tmp/default.log.
  $ echo $fic
  /tmp/default.log

Expression ${variable:+valeur} :

  - Si la variable n'est pas vide, l'expression est substituée par
    "valeur".
  
  - Si la variable est vide, l'expression est substituée par "$variable", donc
    vide.

  $ a=1
  $ echo "Expression : ${a:+99}"
  Expression : 99
  $ unset a
  $ echo "Expression : ${a:+99}"
  Expression : 

Expression ${variable:?message} :

  - Si la variable n'est pas vide, l'expression est substituée par
    "$variable".
  
  - Si la variable est vide, le shell affiche le nom de la variable suivi de
    la chaîne de caractères "message".

  $ echo $var

  $ echo ${var:?"non définie"}
  -bash: var: non définie

Message par défaut :

  $ echo ${var:?}
  -bash: var: parameter null or not set

Définition de la variable :

  $ var=définie
  $ echo ${var:?"non définie"}
  définie


La substitution de commandes
----------------------------

Les caractères de substitution permettent de remplacer une commande par
l'affichage résultant de son exécution. Ce mécanisme est utilisé pour insérer
dans une ligne de commande Unix le résultat d'une autre commande. 

Dans l'exemple qui suit, les commandes 'logname' et 'uname' sont remplacées
par leur résultat avec l'exécution de la commande 'echo'.

  $ echo Vous êtes l\'utilisateur `logname` sur la machine `uname -n`.
  Vous êtes l'utilisateur kikinovak sur la machine alphamule.microlinux.lan.

On préférera la syntaxe alternative :

  $ echo Vous êtes l\'utilisateur $(logname) sur la machine $(uname -n).
  Vous êtes l'utilisateur kikinovak sur la machine alphamule.microlinux.lan.

Dans l'exemple qui suit, on initialise une variable "monuid" avec l'UID de
l'utilisateur "kikinovak".

  $ grep kikinovak /etc/passwd
  kikinovak:x:1000:100:Niki Kovacs,,,:/home/kikinovak:/bin/bash
  $ grep kikinovak /etc/passwd | cut -d: -f3
  1000
  $ monuid=$(grep kikinovak /etc/passwd | cut -d: -f3)
  $ echo $monuid
  1000


Les caractères de protection
----------------------------

Les caractères de protection servent à faire perdre la signification des
caractères spéciaux du shell. Il existe trois jeux de caractères ayant chacun
leur fonctionnalité propre :

  * les simples quotes ' '
  * l'antislash \
  * les guillemets " "

Les simples quotes (ou apostrophes) retirent la signification de tous les
caractères spéciaux du shell. Les quotes doivent être en nombre pair sur une
ligne de commande. Quelques exemples ci-dessous.

  /!\ Les simples quotes ne se protègent pas elles-mêmes.

La variable $HOME est substituée par sa valeur :

  $ echo $HOME
  /home/kikinovak

Le caractère "$" perd sa signification spéciale :

  $ echo '$HOME'
  $HOME

Le caractère "*" est substitué par les noms de fichier du répertoire :

  $ echo *
  f1 f2 fic fic1.txt FIC.c Fic.doc fIc.PDF

Le caractère "*" perd sa signification spéciale :

  $ echo '*'
  *

Le shell s'attend à trouver un nom de fichier derrière une redirection :

  $ echo >
  bash: Erreur de syntaxe près du symbole inattendu « newline »

Le caractère ">" perd sa signification spéciale :

  $ echo '>'
  >

Le shell exécute la commande 'logname' et la remplace par son résultat :

  $ echo Bonjour $(logname)
  Bonjour kikinovak

La séquence de caractères "$( )" perd sa signification spéciale :

  $ echo 'Bonjour $(logname)'
  Bonjour $(logname)

Protection de plusieurs caractères spéciaux :

  $ echo '* ? > < >> << | $HOME $(logname) &'
  * ? > < >> << | $HOME $(logname) &

La quote ne se protège pas elle-même. Pour le shell, la commande n'est pas
terminée. Il affichera le prompt secondaire (PS2) tant que les quotes seront
en nombre impair :

  $ echo 'La quote n'est pas protégée.'
  > 

Le caractère antislash "\" retire la signification spéciale du caractère qui
le suit. Là encore, quelques exemples.

Les caractères "*" et "$" deviennent des caractères ordinaires :

  $ echo Voici une \* et une variable \$HOME.
  Voici une * et une variable $HOME.

L'antislash se protège de lui-même :

  $ echo \\
  \

L'antislah retire la signification spéciale de la quote :

  $ echo L\'antislash protège la quote.
  L'antislash protège la quote.

Le premier antislash protège le deuxième, le troisième protège le "$" :

  $ echo \\\$HOME
  \$HOME

Enfin, les guillemets " " retirent la signification de tous les caractères
spéciaux du shell sauf "$", "` `" et "$( )", "\" et lui-même. 

  $ echo "> et | sont protégés par les guillemets, la valeur de $HOME est \
  substituée, la commande $(logname) est exécutée, l'antislash protège le \
  caractère suivant, ce qui permet d'afficher un \"."
  > et | sont protégés par les guillemets, la valeur de /home/kikinovak est
  substituée, la commande kikinovak est exécutée, l'antislash protège le
  caractère suivant, ce qui permet d'afficher un ".

En pratique, il est fréquent d'encadrer les arguments de la commande 'echo'
avec des guillemets.


Écriture et lancement d'un script shell
---------------------------------------

Un script shell est un fichier texte contenant des commandes Unix internes ou
externes ainsi que des mots clés du shell.

Il n'y a pas de convention imposée pour le nom d'un script shell. Il peut
avoir une extension, mais ce n'est pas obligatoire. Néanmoins, il est assez
fréquent de choisir l'extension ".sh". 

Voici un exemple de script :

  $ nl premier.sh 
       1  pwd
       2  cd /tmp
       3  pwd
       4  ls
       
Exécution du script :

  $ sh premier.sh 
  /home/kikinovak
  /tmp
  blueman-applet-1000

Dans la majorité des cas, les scripts doivent être exécutés par
l'intermédiaire d'un shell enfant. Ceci a pour avantage de ne pas modifier
l'environnement du shell courant. Pour lancer un script shell, il existe trois
méthodes qui produiront un résultat équivalent.

Première méthode :

  $ sh premier.sh

C'est la méthode utilisée précédemment. On appelle la commande 'ksh' en lui
demandant d'interpréter le script 'premier.sh'. Dans ce cas, la permission de
lecture est suffisante sur le fichier 'premier.sh' :

  $ ls -l premier.sh 
  -rw-r--r-- 1 kikinovak users 20 Oct 20 16:26 premier.sh

Deuxième méthode :

  $ sh < premier.sh

Le shell est un programme qui lit sur son entrée standard. Il est donc
possible de connecter celle-ci sur le fichier 'premier.sh'. Là encore, la
permission de lecture est suffisante. Cette syntaxe est peu utilisée. 

Troisième méthode :

  $ chmod u+x premier.sh 
  $ ls -l premier.sh 
  -rwxr--r-- 1 kikinovak users 20 Oct 20 16:26 premier.sh
  $ ./premier.sh 

C'est la méthode la plus utilisée. Dans ce cas, le script est considéré comme
la commande, et donc - comme pour toute commande externe - il est nécessaire
de posséder les droits d'exécution sur le fichier. Par défaut, le script sera
interprété par un shell enfant identique au shell courant.

Sur la première ligne de l'interpréteur, la directive "#!" permet d'imposer
l'interpréteur du script. Le chemin de celui-ci devra être exprimé en absolu.

Reprenons notre exemple en spécifiant l'interpréteur Bash :

  $ nl premier.sh
       1  #! /bin/bash
       2  pwd
       3  cd /tmp
       4  pwd
       5  ls

  /!\ Les caractères "#" et "!" sont écrits respectivement en colonne 1 et 2.
  L'espace entre le "!" et le chemin absolu de l'interpréteur est facultatif. 

Un commentaire commence par le caractère "#" et se termine à la fin de la
ligne. Les lignes blances ainsi que les indentations (espaces, tabulations)
sont ignorées.

  /!\ Une exception à cette règle : si la première ligne du fichier commence
  par "#!", le shell s'attend à trouver le nom de l'interpréteur du script
  juste derrière.

Ajoutons des commentaires à notre script :

  $ nl premier.sh
       1  #! /bin/bash
       2  #
       3  # Voici mon premier script
       4  # comportant des commentaires.
       5  pwd      # Afficher le répertoire courant
       6  cd /tmp  # Changement de répertoire
       7  pwd      # 
       8  ls       # Liste des fichiers du répertoire courant


------------------------------------------------------------------------------
# vim: syntax=txt
