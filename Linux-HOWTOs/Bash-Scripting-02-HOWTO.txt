=======================
Bash Scripting 02 HOWTO (c) Nicolas Kovacs <info@microlinux.fr>
=======================

Dernière révision : 22 octobre 2015

Voici la deuxième partie du HOWTO qui présente les fonctionnalités de base de
la programmation shell.


  * Exécution de tests


Exécution de tests
------------------

Les commandes '[ ]' et '[[ ]]' permettent de réaliser des tests.

  - La commande '[ ]' est utilisable également sous le nom de 'test'. Il
    s'agit de la commande originelle, également compatible avec le shell
    Bourne.

  - La commande '[[ ]]' est un sur-ensemble de la précédente. Elle n'est pas
    compatible avec le shell Bourne.

La commande '[ ]' (ou 'test') permet de faire des tests sur des fichiers, des
chaînes de caractères et des nombres. Elle renvoie le code 0 (vrai) ou 1
(faux), que l'utilisateur peut consulter en faisant afficher la valeur de $?.

La commande 'test' propose deux syntaxes équivalentes :

  $ test expression 

Ou :

  $ [ expression ]

La paire de crochets représente la commande 'test'. Les crochets ouvrant et
fermant sont respectivement suivis et précédés d'un espace. Cette syntaxe est
plus agréable à utiliser. Voici quelques exemples en guise d'illustration.

'/etc/passwd' est un fichier ordinaire :

  $ test -f /etc/passwd
  $ echo $?
  0

Même test, mais avec l'autre syntaxe :

  [ -f /etc/passwd ]
  $ echo $?
  0

Test d'un fichier qui n'existe pas :

  $ [ -f /tmp/yatahongaga ]
  $ echo $?
  1

'/tmp' est un répertoire :

  $ [ -d /tmp ]
  $ echo $?
  0

Le fichier contenu dans la variable "file1" n'est pas un répertoire :

  $ file1=/etc/passwd
  $ test -d $file1
  $ echo $?
  1

L'utilisateur n'a pas le droit d'écriture sur ce fichier :

  $ test -w $file1
  $ echo $?
  1

Voici un tableau récapitulatif des tests les plus courants :

  +------------+-----------------------------------------------+
  | Expression |                  Code retour                  |
  +------------+-----------------------------------------------+
  | -e fichier | 0 si le fichier existe                        |
  | -s fichier | 0 si le fichier n'est pas vide                |
  | -f fichier | 0 si le fichier est de type ordinaire         |
  | -d fichier | 0 si le fichier est un répertoire             |
  | -h fichier | 0 si le fichier est un lien symbolique        |
  | -b fichier | 0 si le fichier est de type spécial bloc      |
  | -c fichier | 0 si le fichier est de type spécial caractère |
  | -r fichier | 0 si le fichier est accessible en lecture     |
  | -w fichier | 0 si le fichier est accessible en écriture    |
  | -x fichier | 0 si le fichier est exécutable                |
  +------------+-----------------------------------------------+

En dehors des fichiers, on peut également effectuer des tests sur les chaînes
de caractères. Une chaîne peut être composée de n'importe quelle suite de
caractères, y compris des chiffres. Il est recommandé de mettre le nom des
variables entre guillemets. 

Initialisation de deux chaînes :

  $ ch1=root
  $ ch2=kikinovak

Les deux chaînes ne sont pas égales :

  $ [ "$ch1" = "$ch2" ]
  $ echo $?
  1

La variable "ch1" n'est pas vide :

  $ [ -n "$ch1" ]
  $ echo $?
  0

Une autre façon de vérifier que la variable "ch1" n'est pas vide :

  $ [ -z "$ch1" ]
  $ echo $?
  1

Les guillemets permettent de transformer du vide en "chaîne vide" :

  $ [ -n "$ch3" ]
  $ echo $?
  1

Voici une petite vue d'ensemble sur les tests que l'on peut effectuer sur les
chaînes de caractères :

  +------------+-----------------------------------------+
  | Expression |               Code retour               |
  +------------+-----------------------------------------+
  | -z chaine1 |  0 si la chaîne est de longueur 0       |
  | -n chaine1 |  0 si la chaîne n'est pas de longueur 0 |
  | ch1 = ch2  |  0 si les deux chaînes sont égales      |
  | ch1 != ch2 |  0 si les deux chaînes sont différentes |
  | chaine1    |  0 si la chaîne n'est pas vide          |
  +------------+-----------------------------------------+

On peut également effectuer des tests sur les nombres. Dans l'exemple
ci-dessous, on commence par saisir deux nombres au clavier.

  $ read nb1
  12
  $ read nb2
  -3
  $ echo $nb1
  12
  $ echo $nb2
  -3

Lorsqu'on compare deux chiffres, il n'est pas indispensable de mettre des
guillemets autour des variables.

Est-ce que la valeur de "nb1" est inférieure à "nb2" ?

  $ [ $nb1 -lt $nb2 ]
  $ echo $?
  1

Est-ce que "nb1" est différent de "nb2" ?

  $ [ $nb1 -ne $nb2 ]
  $ echo $?
  0

Voici les différents tests que l'on peut effectuer sur les nombres :

  +-------------+-----------------+
  | Expression  |   Code retour   |
  +-------------+-----------------+
  | nb1 -eq nb2 | 0 si nb1 =  nb2 |
  | nb1 -ne nb2 | 0 si nb1 != nb2 |
  | nb1 -lt nb2 | 0 si nb1 <  nb2 |
  | nb1 -le nb2 | 0 si nb1 <= nb2 |
  | nb1 -gt nb2 | 0 si nb1 >  nb2 |
  | nb1 -ge nb2 | 0 si nb1 >= nb2 |
  +-------------+-----------------+

Les tests peuvent être combinés avec les trois opérateurs logiques "!"
(négation), '-a' (AND = "et" logique) et '-o' (OR = "ou logique). Il doit y
avoir un espace autour des opérateurs "!", "-a" et "-o".

La commande 'test' renvoie "vrai" si '/etc/passwd' n'est pas un répertoire :

  $ [ ! -d /etc/passwd ]
  $ echo $?
  0

La commande 'test' renvoie "vrai" si $rep est un répertoire et si
l'utilisateur a le droit de le traverser :

  $ rep=/tmp
  $ echo $rep
  /tmp
  $ [ -d $rep -a -x $rep ]
  $ echo $?
  0

Concrètement, la commande 'test' est utilisée avec les structures de contrôle.
La structure de contrôle 'if' est présentée ici dans le but d'illustrer la
commande :

  if commande1
  then
    commande2
    commande3
    ...
  else
    commande4
    ...
  fi

Ou encore :

  if commande1 ; then
    commande2
    commande3
    ...
  else
    commande4
    ...
  fi

Le principe est le suivant : la commande située à droite du 'if' (commande1)
est lancée. Si le code de retour de la commande vaut 0 (vrai), la première
partie du 'if' est exécutée (commande2 et commande3). Dans le cas contraire
($? supérieur à 0), c'est la deuxième partie qui est exécutée (commande4). La
partie 'else' est facultative.

Dans l'exemple qui suit, le script 'testarg.sh' teste le nombre d'arguments
reçus.

  $ nl testarg.sh 
       1  #!/bin/bash
       2  #
       3  # Un script qui teste le nombre d'arguments reçus
         
       4  if [ $# -ne 2 ] ; then
       5    echo "Usage: $0 arg1 arg2"
       6    exit 1
       7  fi
       8  echo "Le nombre d'arguments est correct."
       9  exit 0

Avec deux arguments :

  $ ./testarg.sh fichier1 fichier2
  Le nombre d'arguments est correct.

Avec trois arguments :

  $ ./testarg.sh fichier1 fichier2 fichier3
  Usage: ./testarg.sh arg1 arg2


------------------------------------------------------------------------------
# vim: syntax=txt
